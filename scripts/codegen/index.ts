import { exec } from 'node:child_process'
import fs from 'node:fs/promises'
import { promisify } from 'node:util'
import { type Item, items, type requiredItem } from './config.ts'

// TODO:
// - react hooks/vue composables

console.log('Generating query options.')

const generated = new Map<string, string>()
for (const item of items) {
  const code =
    item.type === 'query' ? genQueryOptions(item) : genMutationOptions(item)
  console.log(
    `- ${item.name}${item.type.charAt(0).toUpperCase() + item.type.slice(1)}Options`,
  )
  generated.set(`packages/core/src/query/${item.name}.ts`, code)
}
// write files
await Promise.all(
  Array.from(generated.entries()).map(([filename, code]) =>
    fs.writeFile(filename, code),
  ),
)

// format output
const execAsync = promisify(exec)
const { stderr } = await execAsync('pnpm biome check --write')
if (stderr) console.error(stderr)

console.log(
  `Generated ${generated.size} query option${generated.size === 1 ? '' : 's'}.`,
)

///

function genMutationOptions(item: Extract<Item, { type: 'mutation' }>) {
  const typePrefix = item.name.charAt(0).toUpperCase() + item.name.slice(1)

  const dataTypeParameters = item.query.data
    .map((x) => getTypeParameter(x))
    .join('')
  const hasConfig = item.query.variables.at(0)?.name === 'config'
  const functionTypeParameters = item.query.variables
    .slice(hasConfig ? 1 : 0)
    .map((x) =>
      getTypeParameter(x, {
        const: true,
        default: item.query.variables.some((x) =>
          Boolean(typeof x === 'object' && x.default),
        ),
      }),
    )
    .join('')
  const variablesTypeParameters = item.query.variables
    .map((x) => getTypeParameter(x))
    .join('')

  const simpleMutate =
    item.query.data.length === 0 && item.query.variables.length === 0
  const dataSlots = item.query.data.map(unwrapName).join(', ')
  const variablesSlots = item.query.variables.map(unwrapName).join(', ')

  const imports = getCoreImports(item)
  const t = 't'

  return `/* generated by scripts/codegen */
import type { MutationObserverOptions${simpleMutate ? '' : ', MutateOptions'} } from '@tanstack/query-core'
import {
  type ${typePrefix}ErrorType,
  type ${typePrefix}Parameters,
  type ${typePrefix}ReturnType,
  ${item.name},
} from '../actions/${item.name}.js'${imports ? `\n${imports}` : ''}
import type { Config } from '../createConfig.js'${simpleMutate ? "\nimport type { Mutate, MutateAsync } from './types.js'" : ''}
import type * as ${t} from '../types/utils.js'

export function ${item.name}MutationOptions${simpleMutate ? '' : '<config extends Config>'}(config: ${simpleMutate ? 'Config' : 'config'}) {
  return {
    mutationFn: (variables) => {
      return ${item.name}(config, variables)
    },
    mutationKey: ['${item.name}'],
  } as const satisfies MutationObserverOptions<
    ${typePrefix}Data${item.query.data.length ? `<${item.query.data.map((x) => x.type).join(', ')}>` : ''},
    ${typePrefix}ErrorType,
    ${typePrefix}Variables${item.query.variables.length ? `<${item.query.variables.map((x) => x.type).join(', ')}>` : ''}
  >
}

export type ${typePrefix}Data${dataTypeParameters ? `<${dataTypeParameters}>` : ''} = ${typePrefix}ReturnType${dataSlots ? `<${dataSlots}>` : ''}

export type ${typePrefix}Variables${variablesTypeParameters ? `<${variablesTypeParameters}>` : ''} = ${typePrefix}Parameters${variablesSlots ? `<${variablesSlots}>` : ''}${item.query.optionalParameters ? ' | undefined' : ''}

export type ${typePrefix}Mutate<${hasConfig ? 'config extends Config, ' : ''}context = unknown> = ${
    simpleMutate
      ? `Mutate<${typePrefix}Data, ${typePrefix}ErrorType, ${typePrefix}Variables, context>`
      : `${functionTypeParameters ? `<${functionTypeParameters}>` : ''}(
  variables: ${typePrefix}Variables${variablesSlots ? `<${variablesSlots}>` : ''},
  options?:
    | ${t}.Compute<
        MutateOptions<
          ${typePrefix}Data${dataSlots ? `<${dataSlots}>` : ''},
          ${typePrefix}ErrorType,
          ${t}.Compute<${typePrefix}Variables${variablesSlots ? `<${variablesSlots}>` : ''}>,
          context
        >
      >
    | undefined,
) => void`
  }

export type ${typePrefix}MutateAsync<${hasConfig ? 'config extends Config, ' : ''}context = unknown> = ${
    simpleMutate
      ? `MutateAsync<${typePrefix}Data, ${typePrefix}ErrorType, ${typePrefix}Variables, context>`
      : `${functionTypeParameters ? `<${functionTypeParameters}>` : ''}(
  variables: ${typePrefix}Variables${variablesSlots ? `<${variablesSlots}>` : ''},
  options?:
    | ${t}.Compute<
        MutateOptions<
          ${typePrefix}Data${dataSlots ? `<${dataSlots}>` : ''},
          ${typePrefix}ErrorType,
          ${t}.Compute<${typePrefix}Variables${variablesSlots ? `<${variablesSlots}>` : ''}>,
          context
        >
      >
    | undefined,
) => Promise<${typePrefix}Data${dataSlots ? `<${dataSlots}>` : ''}>`
  }
`
}

function genQueryOptions(item: Extract<Item, { type: 'query' }>) {
  const typePrefix = item.name.charAt(0).toUpperCase() + item.name.slice(1)

  const optionsTypeParameters = item.query.options
    .map((x) => getTypeParameter(x))
    .join('')
  const functionTypeParameters = item.query.options
    .map((x) =>
      getTypeParameter(x, {
        const: true,
        default: item.query.options.some((x) =>
          Boolean(typeof x === 'object' && x.default),
        ),
      }),
    )
    .join('')
  const dataTypeParameters = item.query.data
    .map((x) => getTypeParameter(x))
    .join('')

  const optionsSlots = item.query.options.map(unwrapName).join(', ')
  const dataSlots = item.query.data.map(unwrapName).join(', ')

  const queryKeySkipped = ['abi', 'connector']
  const getParameterPrefix = (prop: requiredItem) =>
    queryKeySkipped.includes(unwrapName(prop)) ? 'options' : 'parameters'

  const enabled = (() => {
    const o = 'options'
    if (typeof item.required === 'function') return item.required(o).cond
    const get = (
      prop: string | { name: string; cond: (o: string, n: string) => string },
    ) => {
      if (typeof prop === 'string') return `${o}.${prop}`
      return prop.cond(o, prop.name)
    }
    return item.required
      .flatMap((x) => {
        if (Array.isArray(x)) return `Boolean(${x.map(get).join(' || ')})`
        return get(x)
      })
      .join(' && ')
  })()
  const requiredChecks = (() => {
    if (typeof item.required === 'function') {
      const res = item.required('options', 'parameters')
      return `if (!(${res.cond})) throw new Error('${res.message}')`
    }
    const get = (prop: requiredItem) => {
      const o = getParameterPrefix(prop)
      if (typeof prop === 'string') return `${o}.${prop}`
      return prop.cond(o, prop.name)
    }
    return item.required
      .map((x) => {
        if (Array.isArray(x))
          return `if (${x.map((y) => `!${get(y)}`).join(' && ')}) throw new Error('${x.length > 2 ? x.map((y, i) => `${i === x.length - 1 ? 'or ' : ''}${unwrapName(y)}`).join(', ') : x.map(unwrapName).join(' or ')} is required')`
        return `if (!${get(x)}) throw new Error('${unwrapName(x)} is required')`
      })
      .join('\n')
  })()
  const requiredParameters = [
    ...(typeof item.required === 'function' ? [] : item.required).flatMap(
      (x) => {
        const get = (prop: requiredItem) => {
          const o = getParameterPrefix(prop)
          if (typeof prop === 'string') return `${o}.${prop}`
          if (queryKeySkipped.includes(prop.name)) return `${o}.${prop.name}`
          return `${prop.cond(o, prop.name)} ? ${o}.${prop.name} : undefined`
        }
        if (Array.isArray(x)) return x.map((y) => `${unwrapName(y)}: ${get(y)}`)
        return `${unwrapName(x)}: ${get(x)}`
      },
    ),
    ...(item.query.skipped?.map((x) => `${unwrapName(x)}: options.${x}`) ?? []),
  ].join(', ')

  const t = 't'
  const optionsType =
    item.query.optionsType ??
    ((t: string, typePrefix: string, slots: string, extras: string) =>
      `${t}.Compute<${t}.ExactPartial<${typePrefix}Parameters<${slots}>> & ${extras}>`)

  const hasConnectorUid = (() => {
    if (typeof item.required === 'function')
      return /options\.connector(?:\s|$)/.test(item.required('options').cond)
    const filteredProperties = [
      ...new Set(
        item.required
          .flatMap((x) => (Array.isArray(x) ? x : [x]).map(unwrapName))
          .filter((x) => queryKeySkipped.includes(x)),
      ).values(),
    ]
    return filteredProperties.includes('connector')
  })()

  const imports = getCoreImports(item)

  return `/* generated by scripts/codegen */
import type { QueryObserverOptions } from '@tanstack/query-core'
import {
  type ${typePrefix}ErrorType,
  type ${typePrefix}Parameters,
  type ${typePrefix}ReturnType,
  ${item.name},
} from '../actions/${item.name}.js'${imports ? `\n${imports}` : ''}
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type * as ${t} from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type ${typePrefix}Options<${optionsTypeParameters}> = ${optionsType(t, typePrefix, optionsSlots, 'ScopeKeyParameter')}

export function ${item.name}QueryOptions<${functionTypeParameters}>(
  config: config,
  options: ${typePrefix}Options<${optionsSlots}> = {}${item.query.cast?.options ? ' as never' : ''},
) {
  return {${enabled ? `\nenabled: Boolean(${enabled}),` : ''}
    queryFn: async (context) => {
      const { scopeKey: _, ...parameters } = context.queryKey[1]${requiredChecks ? `\n${requiredChecks}` : ''}
      const result = await ${item.name}(config, ${requiredParameters ? `{ ...(parameters${item.query.cast?.parameters ? ' as any' : ''}), ${requiredParameters}}` : `parameters${item.query.cast?.parameters ? ' as never' : ''}`})
      return (result ?? null)${item.query.cast?.return ? ` as unknown as ${typePrefix}Data${dataSlots ? `<${dataSlots}>` : ''}` : ''}
    },
    queryKey: ${item.name}QueryKey(options${item.query.cast?.queryKey ? ' as never' : ''}),${item.query.extraOptions?.length ? item.query.extraOptions.map((x) => `${x.name}: ${x.default}`).join(',\n') : ''}
  } as const satisfies QueryObserverOptions<
    ${typePrefix}QueryFnData${dataSlots ? `<${dataSlots}>` : ''},
    ${typePrefix}ErrorType,
    ${typePrefix}Data${dataSlots ? `<${dataSlots}>` : ''},
    ${typePrefix}QueryFnData${dataSlots ? `<${dataSlots}>` : ''},
    ${typePrefix}QueryKey${optionsSlots ? `<${optionsSlots}>` : ''}
  >
}

export type ${typePrefix}QueryFnData${dataTypeParameters ? `<${dataTypeParameters}>` : ''} = t.Compute<${typePrefix}ReturnType${dataSlots ? `<${dataSlots}>` : ''}>

export type ${typePrefix}Data${dataTypeParameters ? `<${dataTypeParameters}>` : ''} = ${typePrefix}QueryFnData${dataSlots ? `<${dataSlots}>` : ''}

export function ${item.name}QueryKey<${functionTypeParameters}>(
  ${item.query.skipped ? `{ ${item.query.skipped.map((x, i) => `${x}: ${'_'.repeat(i + 1)}`).join(', ')}, ...options }` : 'options'}: ${typePrefix}Options<${optionsSlots}> = {}${item.query.cast?.options ? ' as never' : ''},
) {
  return ['${item.name}', filterQueryOptions(${hasConnectorUid ? '{ ...options, connectorUid: options.connector?.uid }' : 'options'})] as const
}

export type ${typePrefix}QueryKey<${optionsTypeParameters}> = ReturnType<
  typeof ${item.name}QueryKey<${optionsSlots}>
>
`
}

function unwrapName(value: string | { name: string }) {
  if (typeof value === 'string') return value
  return value.name
}

function getTypeParameter(
  item: 'chainId' | 'config' | { name: string; type: string },
  opts: { const?: true; default?: boolean } = {},
) {
  const unwrapped =
    typeof item === 'object'
      ? item
      : {
          name: item,
          type:
            item === 'chainId' ? "config['chains'][number]['id']" : 'Config',
          default:
            item === 'chainId' ? "config['chains'][number]['id']" : 'Config',
          const: false,
        }
  return `\n${opts.const && 'const' in unwrapped && unwrapped.const ? 'const ' : ''}${unwrapped.name}${unwrapped.type ? ` extends ${unwrapped.type}` : ''}${opts.default && 'default' in unwrapped && unwrapped.default ? `= ${unwrapped.default}` : ''},`
}

function getCoreImports(item: Item) {
  const viemImports = item.query.imports.filter((x) => typeof x === 'string')
  const customImports = item.query.imports
    .filter((x) => typeof x === 'object')
    .map((x) => `import { ${x.names.join(', ')} } from '${x.path}'`)
  return [
    ...(viemImports.length
      ? [`import type { ${viemImports.join(', ')} } from 'viem'`]
      : []),
    ...(customImports.length ? customImports : []),
  ].join('\n')
}
